{
  "version": 3,
  "sources": ["../src/main/attributes.ts", "../src/main/state.ts", "../src/main/observers.ts", "../src/main/on.ts", "../src/main/reusable.ts", "../src/main/remove.ts", "../src/main/jot.ts", "../src/main/tags.ts", "../src/main/utils.ts", "../src/main/css.ts"],
  "sourcesContent": ["import { hook, type Hook } from \"./mod.ts\";\n\n/**\n *\n * @param attributes\n * @param namespace\n * @returns\n */\nexport function attributes<E extends Element>(\n  attributes: Record<string, unknown>,\n  namespace?: string | null,\n): Hook<E> {\n  namespace ||= null;\n\n  return hook((element) => {\n    for (const [name, value] of Object.entries(attributes)) {\n      if (value == null) {\n        return element.removeAttributeNS(namespace, name);\n      }\n\n      element.setAttributeNS(namespace, name, String(value));\n    }\n  });\n}\n", "/**\n *\n */\nexport interface Disposable {\n  [disposal](): void;\n}\n\n/**\n *\n */\nexport type Mutable<S extends object> = S & {\n  readonly [P in Extract<keyof S, string> as `${typeof prefix}${P}`]: S[P];\n};\n\ninterface Observable {\n  distance: number;\n  observers: Set<symbol>;\n  update?: VoidFunction;\n}\n\nconst disposal: unique symbol = Symbol();\n\nconst prefix = \"$\";\nconst session = new Set<symbol>();\nconst observables = new WeakMap<symbol, Observable>();\n\nlet targets: Set<symbol> | undefined;\n\nfunction byDistance(a: symbol, b: symbol): number {\n  return toDistance(a) - toDistance(b);\n}\n\nfunction commit(): void {\n  for (const update of [...session].sort(byDistance).map(toUpdate)) {\n    if (update) {\n      queueMicrotask(update);\n    }\n  }\n\n  session.clear();\n}\n\nfunction defer(update: symbol): void {\n  if (session.has(update)) {\n    return;\n  }\n\n  if (session.size === 0) {\n    queueMicrotask(commit);\n  }\n\n  session.add(update);\n\n  for (const observer of observables.get(update)?.observers || []) {\n    defer(observer);\n  }\n}\n\n/**\n *\n * @param state\n * @returns\n */\nexport function derived<S extends object>(\n  state: () => S | void,\n): Readonly<S> & Disposable {\n  const [dependencies, restore] = prepare(targets);\n  const mutable = <S>{};\n\n  try {\n    Object.assign(mutable, state());\n  } finally {\n    restore();\n  }\n\n  const id = Symbol();\n\n  for (const dependency of dependencies) {\n    observables.get(dependency)?.observers.add(id);\n  }\n\n  observables.set(id, {\n    distance: [...dependencies].map(toDistance).reduce(toMax, -1) + 1,\n    observers: new Set(),\n    update() {\n      Object.assign(mutable, state());\n    },\n  });\n\n  return new Proxy(<Readonly<S> & Disposable>mutable, {\n    get(target, property, receiver) {\n      if (property === disposal) {\n        return () => {\n          for (const dependency of dependencies) {\n            observables.get(dependency)?.observers.delete(id);\n          }\n\n          dependencies.clear();\n          dependencies.delete(id);\n        };\n      }\n\n      targets?.add(id);\n\n      return Reflect.get(target, property, receiver);\n    },\n    set() {\n      return false;\n    },\n  });\n}\n\n/**\n *\n * @param disposables\n */\nexport function dispose(...disposables: Disposable[]) {\n  for (const disposable of disposables) {\n    disposable[disposal]();\n  }\n}\n\n/**\n *\n * @param state\n * @returns\n */\nexport function mutable<S extends object>(state: S): Mutable<S> {\n  const id = Symbol();\n\n  observables.set(id, {\n    distance: 0,\n    observers: new Set(),\n  });\n\n  return new Proxy(<Mutable<S>>state, {\n    get(target, property, receiver) {\n      if (typeof property === \"string\" && property.startsWith(prefix)) {\n        return (\n          defer(id),\n          Reflect.get(target, property.substring(prefix.length), receiver)\n        );\n      }\n\n      targets?.add(id);\n\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      if (typeof property === \"string\" && property.startsWith(prefix)) {\n        return false;\n      }\n\n      defer(id);\n\n      return Reflect.set(target, property, value, receiver);\n    },\n  });\n}\n\nfunction prepare(\n  dependencies: Set<symbol> | undefined,\n): [Set<symbol>, VoidFunction] {\n  return [(targets = new Set()), () => (targets = dependencies)];\n}\n\nfunction toDistance(observable: symbol): number {\n  return observables.get(observable)?.distance || 0;\n}\n\nfunction toMax(a: number, b: number): number {\n  return Math.max(a, b);\n}\n\nfunction toUpdate(observable: symbol): VoidFunction | undefined {\n  return observables.get(observable)?.update;\n}\n", "import { derived, dispose, type Disposable } from \"./state.ts\";\n\nconst disposables = new WeakMap<Node, Disposable[]>();\n\n/**\n *\n * @param node\n * @param observers\n */\nexport function addObservers(node: Node, ...observers: VoidFunction[]) {\n  let list = disposables.get(node);\n\n  if (!list) {\n    disposables.set(node, (list = []));\n  }\n\n  list.push(...observers.map(derived));\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeObservers(node: Node): void {\n  const list = disposables.get(node);\n\n  if (!list) {\n    return;\n  }\n\n  for (const disposable of list) {\n    dispose(disposable);\n  }\n\n  disposables.delete(node);\n}\n", "import { hook, type Hook } from \"./jot.ts\";\n\nconst listeners = new WeakMap<\n  Node,\n  [\n    string,\n    EventListenerOrEventListenerObject | null,\n    AddEventListenerOptions | boolean | undefined,\n  ][]\n>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeEventListeners(node: Node): void {\n  for (const [type, listener, options] of listeners.get(node) || []) {\n    node.removeEventListener(type, listener, options);\n  }\n}\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node, T extends keyof E, E = HTMLElementEventMap>(\n  type: T,\n  listener: (this: N, event: E[T]) => unknown,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node>(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\nexport function on(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<Node> {\n  return hook((node) => {\n    node.addEventListener(type, listener, options);\n\n    if (listeners.get(node)?.push([type, listener, options]) === undefined) {\n      listeners.set(node, [[type, listener, options]]);\n    }\n  });\n}\n", "const reusableNodes = new WeakSet<Node>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function isReusable(node: Node): boolean {\n  return reusableNodes.has(node);\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function reusable<N extends Node>(node: N): N {\n  return reusableNodes.add(node), node;\n}\n", "import { removeObservers } from \"./observers.ts\";\nimport { removeEventListeners } from \"./on.ts\";\nimport { isReusable } from \"./reusable.ts\";\n\n/**\n *\n * @param node\n * @param force\n */\nexport function remove(node: Node, force?: boolean): void {\n  if (!force && isReusable(node)) {\n    return;\n  }\n\n  for (const child of [...node.childNodes]) {\n    remove(child, force);\n  }\n\n  removeObservers(node);\n  removeEventListeners(node);\n  node.parentNode?.removeChild(node);\n}\n", "import { addObservers } from \"./observers.ts\";\nimport { remove } from \"./remove.ts\";\n\n/**\n *\n */\nexport interface Callback<N extends Node> {\n  (node: N): Option<N>;\n}\n\n/**\n *\n */\nexport interface Hook<N extends Node> {\n  [hookTo](node: N): Option<N>;\n}\n\ninterface NodeConsumer {\n  (node: Node): void;\n}\n\n/**\n *\n */\nexport type Option<N extends Node> =\n  | bigint\n  | boolean\n  | Callback<N>\n  | Hook<N>\n  | Node\n  | null\n  | number\n  | Option<N>[]\n  | Properties<N>\n  | string\n  | symbol\n  | undefined\n  | void;\n\n/**\n *\n */\nexport type Properties<N extends Node> = Partial<Omit<N, \"nodeType\">>;\n\nconst hookTo: unique symbol = Symbol();\n\nfunction apply<N extends Node>(\n  node: N,\n  option: Option<N>,\n  applyNode: NodeConsumer,\n): void {\n  if (option == null) {\n    return;\n  }\n\n  switch (typeof option) {\n    case \"function\":\n      return applyCallback(node, option, applyNode);\n\n    case \"object\":\n      if (hookTo in option) {\n        return apply(node, option[hookTo](node), applyNode);\n      }\n\n      if (\"nodeType\" in option) {\n        return applyNode(option);\n      }\n\n      if (Array.isArray(option)) {\n        for (const nested of option) {\n          apply(node, nested, applyNode);\n        }\n      } else {\n        Object.assign(node, option);\n      }\n\n      return;\n  }\n\n  if (node.ownerDocument) {\n    applyNode(node.ownerDocument.createTextNode(String(option)));\n  }\n}\n\nfunction applyCallback<N extends Node>(\n  node: N,\n  callback: Callback<N>,\n  applyNode: NodeConsumer,\n): void {\n  const children: Node[] = [];\n\n  let start: Text;\n  let end: Text;\n\n  function applyChildNode(child: Node) {\n    children.push(child);\n  }\n\n  function update() {\n    const document = node.ownerDocument;\n\n    if (!document) {\n      return;\n    }\n\n    if (!start) {\n      if (children.length === 0) {\n        return;\n      }\n\n      applyNode((start = document.createTextNode(\"\")));\n      applyNode((end = document.createTextNode(\"\")));\n    }\n\n    const range = document.createRange();\n\n    range.setStartAfter(start);\n    range.setEndBefore(end);\n\n    const contents = range.extractContents();\n\n    setTimeout(remove, 100, contents);\n\n    if (children.length === 0) {\n      return;\n    }\n\n    const fragment = document.createDocumentFragment();\n\n    fragment.append(...children);\n    range.insertNode(fragment);\n  }\n\n  addObservers(node, () => {\n    apply(node, callback(node), applyChildNode);\n    update();\n\n    children.length = 0;\n  });\n}\n\n/**\n *\n * @param callback\n * @returns\n */\nexport function hook<N extends Node>(callback: Callback<N>): Hook<N> {\n  return {\n    [hookTo]: callback,\n  };\n}\n\n/**\n *\n * @param node\n * @param options\n * @returns\n */\nexport function jot<N extends Node>(node: N, ...options: Option<N>[]): N {\n  function applyNode(child: Node) {\n    node.appendChild(child);\n  }\n\n  for (const option of options) {\n    apply(node, option, applyNode);\n  }\n\n  return node;\n}\n", "import { jot, type Option } from \"./jot.ts\";\n\n/**\n *\n */\nexport type Tags<E extends Record<keyof E, Node>> = {\n  readonly [T in keyof E]: (...options: Option<E[T]>[]) => E[T];\n};\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace?: \"http://www.w3.org/1999/xhtml\",\n): Tags<HTMLElementTagNameMap> & Tags<HTMLElementDeprecatedTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/1998/Math/MathML\",\n): Tags<MathMLElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/2000/svg\",\n): Tags<SVGElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: string | null,\n): Tags<Record<string, Element>>;\n\nexport function tags(document: Document, namespace?: string | null) {\n  const createElement: (tag: string) => Element =\n    namespace === undefined\n      ? (tag) => document.createElement(tag)\n      : (tag) => document.createElementNS(namespace, tag);\n\n  return new Proxy(\n    {},\n    {\n      get(_, property) {\n        if (typeof property !== \"string\") {\n          return undefined;\n        }\n\n        return (...options: Option<Node>[]) => {\n          return jot(createElement(property), ...options);\n        };\n      },\n    },\n  );\n}\n", "import { hook, jot, type Hook, type Option } from \"./jot.ts\";\n\nlet value = 0n;\n\nexport function fragment<N extends Node>(\n  ...options: Option<DocumentFragment>[]\n): Hook<N> {\n  return hook((node) => {\n    if (node.ownerDocument) {\n      return jot(node.ownerDocument?.createDocumentFragment(), ...options);\n    }\n  });\n}\n\n/**\n *\n * @returns\n */\nexport function id<E extends Element>(): string & Hook<E> {\n  const id = String(value++);\n\n  return Object.assign(\n    id,\n    hook<E>((element) => {\n      element.id = id;\n    }),\n  );\n}\n", "import { hook, type Hook } from \"./jot.ts\";\nimport { id } from \"./utils.ts\";\n\n/**\n *\n */\nexport type Style = Partial<StyleProperties> & {\n  [key: string]: string | Style | Style[];\n};\n\n/**\n *\n */\nexport type StyleProperties = Omit<\n  CSSStyleDeclaration,\n  | \"getPropertyPriority\"\n  | \"getPropertyValue\"\n  | \"item\"\n  | \"length\"\n  | \"parentRule\"\n  | \"removeProperty\"\n  | \"setProperty\"\n  | number\n  | SymbolConstructor[\"iterator\"]\n>;\n\nconst styles = new WeakSet<symbol>();\nconst upperCaseLetters = /([A-Z])/g;\n\nlet stylePrefix: string | undefined;\nlet styleSheet: CSSStyleSheet | null;\n\n/**\n *\n * @param style\n * @returns\n */\nexport function css<E extends Element>(style: Style): string & Hook<E> {\n  const styleId = Symbol();\n  const className = (stylePrefix || \"s\") + id();\n\n  return Object.assign(\n    className,\n    hook<E>((element) => {\n      if (!styles.has(styleId)) {\n        insert(\n          getStyleSheet(element.ownerDocument),\n          `.${className}`,\n          toString(style),\n        );\n      }\n\n      element.classList.add(className);\n    }),\n  );\n}\n\nfunction getStyleSheet(document: Document): CSSStyleSheet {\n  if (styleSheet) {\n    return styleSheet;\n  }\n\n  const style = document.createElement(\"style\");\n\n  document.head.appendChild(style);\n\n  styleSheet = style.sheet;\n\n  return getStyleSheet(document);\n}\n\n/**\n *\n * @param style\n * @returns\n */\nexport function globalCss<E extends Element>(style: Style): Hook<E> {\n  const styleId = Symbol();\n\n  return hook((element) => {\n    if (styles.has(styleId)) {\n      return;\n    }\n\n    const styleSheet = getStyleSheet(element.ownerDocument);\n\n    for (const [selector, value] of Object.entries(style)) {\n      if (typeof value === \"string\") {\n        insert(styleSheet, selector, value);\n      } else {\n        for (const style of Array.isArray(value) ? value : [value]) {\n          insert(styleSheet, selector, toString(style));\n        }\n      }\n    }\n\n    styles.add(styleId);\n  });\n}\n\nfunction insert(styleSheet: CSSStyleSheet, selector: string, rule: string) {\n  styleSheet.insertRule(`${selector}{${rule}}`, styleSheet.cssRules.length);\n}\n\n/**\n *\n * @param prefix\n */\nexport function setStylePrefix(prefix: string): void {\n  stylePrefix = prefix;\n}\n\n/**\n *\n * @param sheet\n */\nexport function setStyleSheet(sheet: CSSStyleSheet | null): void {\n  styleSheet = sheet;\n}\n\n/**\n *\n * @param className\n * @param force\n * @returns\n */\nexport function toggle<E extends Element>(\n  className: string,\n  force?: boolean,\n): Hook<E> {\n  return hook((element) => {\n    element.classList.toggle(className, force);\n  });\n}\n\nfunction toString(style: Style): string {\n  return Object.entries(style).map(toStyleString).join(\"\");\n}\n\nfunction toStyleString([key, style]: [\n  string,\n  string | Style | Style[],\n]): string {\n  if (typeof style === \"string\") {\n    if (!key.startsWith(\"--\")) {\n      key = key.replaceAll(upperCaseLetters, \"-$1\").toLowerCase();\n    }\n\n    return `${key}:${style};`;\n  }\n\n  if (!Array.isArray(style)) {\n    style = [style];\n  }\n\n  return style.map((style) => `${key}{${toString(style)}}`).join(\"\");\n}\n"],
  "mappings": "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",
  "names": ["attributes", "namespace", "hook", "element", "name", "value", "disposal", "prefix", "session", "observables", "targets", "byDistance", "a", "b", "toDistance", "commit", "update", "toUpdate", "defer", "observer", "derived", "state", "dependencies", "restore", "prepare", "mutable", "id", "dependency", "toMax", "target", "property", "receiver", "dispose", "disposables", "disposable", "value", "observable", "disposables", "addObservers", "node", "observers", "list", "derived", "removeObservers", "disposable", "dispose", "listeners", "removeEventListeners", "node", "type", "listener", "options", "on", "hook", "reusableNodes", "isReusable", "node", "reusable", "remove", "node", "force", "isReusable", "child", "removeObservers", "removeEventListeners", "hookTo", "apply", "node", "option", "applyNode", "applyCallback", "nested", "callback", "children", "start", "end", "applyChildNode", "child", "update", "document", "range", "contents", "remove", "fragment", "addObservers", "hook", "jot", "options", "tags", "document", "namespace", "createElement", "tag", "_", "property", "options", "jot", "value", "fragment", "options", "hook", "node", "jot", "id", "element", "styles", "upperCaseLetters", "stylePrefix", "styleSheet", "css", "style", "styleId", "className", "id", "hook", "element", "insert", "getStyleSheet", "toString", "document", "globalCss", "selector", "value", "rule", "setStylePrefix", "prefix", "setStyleSheet", "sheet", "toggle", "force", "toStyleString", "key"]
}
