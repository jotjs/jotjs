{
  "version": 3,
  "sources": ["../src/main/state.ts", "../src/main/observers.ts", "../src/main/on.ts", "../src/main/reusable.ts", "../src/main/remove.ts", "../src/main/jot.ts", "../src/main/attributes.ts", "../src/main/tags.ts"],
  "sourcesContent": ["/**\n *\n */\nexport interface Disposable {\n  [disposal](): void;\n}\n\n/**\n *\n */\nexport type Mutable<S extends object> = S & {\n  readonly [P in Extract<keyof S, string> as `${typeof prefix}${P}`]: S[P];\n};\n\ninterface Observable {\n  distance: number;\n  observers: Set<symbol>;\n  update?: VoidFunction;\n}\n\nconst disposal: unique symbol = Symbol();\n\nconst prefix = \"$\";\nconst session = new Set<symbol>();\nconst observables = new WeakMap<symbol, Observable>();\n\nlet targets: Set<symbol> | undefined;\n\nfunction byDistance(a: symbol, b: symbol): number {\n  return toDistance(a) - toDistance(b);\n}\n\nfunction commit(): void {\n  for (const update of [...session].sort(byDistance).map(toUpdate)) {\n    if (update) {\n      queueMicrotask(update);\n    }\n  }\n\n  session.clear();\n}\n\nfunction defer(update: symbol): void {\n  if (session.has(update)) {\n    return;\n  }\n\n  if (session.size === 0) {\n    queueMicrotask(commit);\n  }\n\n  session.add(update);\n\n  for (const observer of observables.get(update)?.observers || []) {\n    defer(observer);\n  }\n}\n\n/**\n *\n * @param state\n * @returns\n */\nexport function derived<S extends object>(\n  state: () => S | void,\n): Readonly<S> & Disposable {\n  const [dependencies, restore] = prepare(targets);\n  const mutable = <S>{};\n\n  try {\n    Object.assign(mutable, state());\n  } finally {\n    restore();\n  }\n\n  const id = Symbol();\n\n  for (const dependency of dependencies) {\n    observables.get(dependency)?.observers.add(id);\n  }\n\n  observables.set(id, {\n    distance: [...dependencies].map(toDistance).reduce(toMax, -1) + 1,\n    observers: new Set(),\n    update() {\n      Object.assign(mutable, state());\n    },\n  });\n\n  return new Proxy(<Readonly<S> & Disposable>mutable, {\n    get(target, property, receiver) {\n      if (property === disposal) {\n        return () => {\n          for (const dependency of dependencies) {\n            observables.get(dependency)?.observers.delete(id);\n          }\n\n          dependencies.clear();\n          dependencies.delete(id);\n        };\n      }\n\n      targets?.add(id);\n\n      return Reflect.get(target, property, receiver);\n    },\n    set() {\n      return false;\n    },\n  });\n}\n\n/**\n *\n * @param disposables\n */\nexport function dispose(...disposables: Disposable[]) {\n  for (const disposable of disposables) {\n    disposable[disposal]();\n  }\n}\n\n/**\n *\n * @param state\n * @returns\n */\nexport function mutable<S extends object>(state: S): Mutable<S> {\n  const id = Symbol();\n\n  observables.set(id, {\n    distance: 0,\n    observers: new Set(),\n  });\n\n  return new Proxy(<Mutable<S>>state, {\n    get(target, property, receiver) {\n      if (typeof property === \"string\" && property.startsWith(prefix)) {\n        return (\n          defer(id),\n          Reflect.get(target, property.substring(prefix.length), receiver)\n        );\n      }\n\n      targets?.add(id);\n\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      if (typeof property === \"string\" && property.startsWith(prefix)) {\n        return false;\n      }\n\n      defer(id);\n\n      return Reflect.set(target, property, value, receiver);\n    },\n  });\n}\n\nfunction prepare(\n  dependencies: Set<symbol> | undefined,\n): [Set<symbol>, VoidFunction] {\n  return [(targets = new Set()), () => (targets = dependencies)];\n}\n\nfunction toDistance(observable: symbol): number {\n  return observables.get(observable)?.distance || 0;\n}\n\nfunction toMax(a: number, b: number): number {\n  return Math.max(a, b);\n}\n\nfunction toUpdate(observable: symbol): VoidFunction | undefined {\n  return observables.get(observable)?.update;\n}\n", "import { derived, dispose, type Disposable } from \"./state.ts\";\n\nconst disposables = new WeakMap<Node, Disposable[]>();\n\n/**\n *\n * @param node\n * @param observers\n */\nexport function addObservers(node: Node, ...observers: VoidFunction[]) {\n  let list = disposables.get(node);\n\n  if (!list) {\n    disposables.set(node, (list = []));\n  }\n\n  list.push(...observers.map(derived));\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeObservers(node: Node): void {\n  const list = disposables.get(node);\n\n  if (!list) {\n    return;\n  }\n\n  for (const disposable of list) {\n    dispose(disposable);\n  }\n\n  disposables.delete(node);\n}\n", "import { hook, type Hook } from \"./jot.ts\";\n\nconst listeners = new WeakMap<\n  Node,\n  [\n    string,\n    EventListenerOrEventListenerObject | null,\n    AddEventListenerOptions | boolean | undefined,\n  ][]\n>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeEventListeners(node: Node): void {\n  for (const [type, listener, options] of listeners.get(node) || []) {\n    node.removeEventListener(type, listener, options);\n  }\n}\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node, T extends keyof E, E = HTMLElementEventMap>(\n  type: T,\n  listener: (this: N, event: E[T]) => unknown,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node>(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\nexport function on(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<Node> {\n  return hook((node) => {\n    node.addEventListener(type, listener, options);\n\n    if (listeners.get(node)?.push([type, listener, options]) === undefined) {\n      listeners.set(node, [[type, listener, options]]);\n    }\n  });\n}\n", "const reusableNodes = new WeakSet<Node>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function isReusable(node: Node): boolean {\n  return reusableNodes.has(node);\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function reusable<N extends Node>(node: N): N {\n  return reusableNodes.add(node), node;\n}\n", "import { removeObservers } from \"./observers.ts\";\nimport { removeEventListeners } from \"./on.ts\";\nimport { isReusable } from \"./reusable.ts\";\n\n/**\n *\n * @param node\n * @param force\n */\nexport function remove(node: Node, force?: boolean): void {\n  if (!force && isReusable(node)) {\n    return;\n  }\n\n  for (const child of [...node.childNodes]) {\n    remove(child, force);\n  }\n\n  removeObservers(node);\n  removeEventListeners(node);\n  node.parentNode?.removeChild(node);\n}\n", "import { addObservers } from \"./observers.ts\";\nimport { remove } from \"./remove.ts\";\n\n/**\n *\n */\nexport interface Callback<N extends Node> {\n  (node: N): Option<N>;\n}\n\n/**\n *\n */\nexport interface Hook<N extends Node> {\n  [hookTo](node: N): Option<N>;\n}\n\ninterface NodeConsumer {\n  (node: Node): void;\n}\n\n/**\n *\n */\nexport type Option<N extends Node> =\n  | bigint\n  | boolean\n  | Callback<N>\n  | Hook<N>\n  | Node\n  | null\n  | number\n  | Option<N>[]\n  | Properties<N>\n  | string\n  | symbol\n  | undefined\n  | void;\n\n/**\n *\n */\nexport type Properties<N extends Node> = Partial<Omit<N, \"nodeType\">>;\n\nconst hookTo: unique symbol = Symbol();\n\nfunction apply<N extends Node>(\n  node: N,\n  option: Option<N>,\n  applyNode: NodeConsumer,\n): void {\n  if (option == null) {\n    return;\n  }\n\n  switch (typeof option) {\n    case \"function\":\n      return applyCallback(node, option, applyNode);\n\n    case \"object\":\n      if (hookTo in option) {\n        return apply(node, option[hookTo](node), applyNode);\n      }\n\n      if (\"nodeType\" in option) {\n        return applyNode(option);\n      }\n\n      if (Array.isArray(option)) {\n        for (const nested of option) {\n          apply(node, nested, applyNode);\n        }\n      } else {\n        Object.assign(node, option);\n      }\n\n      return;\n  }\n\n  if (node.ownerDocument) {\n    applyNode(node.ownerDocument.createTextNode(String(option)));\n  }\n}\n\nfunction applyCallback<N extends Node>(\n  node: N,\n  callback: Callback<N>,\n  applyNode: NodeConsumer,\n): void {\n  const children: Node[] = [];\n\n  let start: Text;\n  let end: Text;\n\n  function applyChildNode(child: Node) {\n    children.push(child);\n  }\n\n  function update() {\n    const document = node.ownerDocument;\n\n    if (!document) {\n      return;\n    }\n\n    if (!start) {\n      if (children.length === 0) {\n        return;\n      }\n\n      applyNode((start = document.createTextNode(\"\")));\n      applyNode((end = document.createTextNode(\"\")));\n    }\n\n    const range = document.createRange();\n\n    range.setStartAfter(start);\n    range.setEndBefore(end);\n\n    const contents = range.extractContents();\n\n    setTimeout(remove, 100, contents);\n\n    if (children.length === 0) {\n      return;\n    }\n\n    const fragment = document.createDocumentFragment();\n\n    fragment.append(...children);\n    range.insertNode(fragment);\n  }\n\n  addObservers(node, () => {\n    apply(node, callback(node), applyChildNode);\n    update();\n\n    children.length = 0;\n  });\n}\n\n/**\n *\n * @param callback\n * @returns\n */\nexport function hook<N extends Node>(callback: Callback<N>): Hook<N> {\n  return {\n    [hookTo]: callback,\n  };\n}\n\n/**\n *\n * @param node\n * @param options\n * @returns\n */\nexport function jot<N extends Node>(node: N, ...options: Option<N>[]): N {\n  function applyNode(child: Node) {\n    node.appendChild(child);\n  }\n\n  for (const option of options) {\n    apply(node, option, applyNode);\n  }\n\n  return node;\n}\n", "import { hook, type Hook } from \"./mod.ts\";\n\n/**\n *\n * @param attributes\n * @param namespace\n * @returns\n */\nexport function attributes<E extends Element>(\n  attributes: Record<string, unknown>,\n  namespace?: string | null,\n): Hook<E> {\n  namespace ||= null;\n\n  return hook((element) => {\n    for (const [name, value] of Object.entries(attributes)) {\n      if (value == null) {\n        return element.removeAttributeNS(namespace, name);\n      }\n\n      element.setAttributeNS(namespace, name, String(value));\n    }\n  });\n}\n", "import { jot, type Option } from \"./jot.ts\";\n\n/**\n *\n */\nexport type Tags<E extends Record<keyof E, Node>> = {\n  readonly [T in keyof E]: (...options: Option<E[T]>[]) => E[T];\n};\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace?: \"http://www.w3.org/1999/xhtml\",\n): Tags<HTMLElementTagNameMap> & Tags<HTMLElementDeprecatedTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/1998/Math/MathML\",\n): Tags<MathMLElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/2000/svg\",\n): Tags<SVGElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n */\nexport function tags(\n  document: Document,\n  namespace: string | null,\n): Tags<Record<string, Element>>;\n\nexport function tags(document: Document, namespace?: string | null) {\n  const createElement: (tag: string) => Element =\n    namespace === undefined\n      ? (tag) => document.createElement(tag)\n      : (tag) => document.createElementNS(namespace, tag);\n\n  return new Proxy(\n    {},\n    {\n      get(_, property) {\n        if (typeof property !== \"string\") {\n          return undefined;\n        }\n\n        return (...options: Option<Node>[]) => {\n          return jot(createElement(property), ...options);\n        };\n      },\n    },\n  );\n}\n"],
  "mappings": ";AAoBA,IAAM,WAA0B,OAAO;AAEvC,IAAM,SAAS;AACf,IAAM,UAAU,oBAAI,IAAY;AAChC,IAAM,cAAc,oBAAI,QAA4B;AAEpD,IAAI;AAEJ,SAAS,WAAW,GAAW,GAAmB;AAChD,SAAO,WAAW,CAAC,IAAI,WAAW,CAAC;AACrC;AAEA,SAAS,SAAe;AACtB,aAAW,UAAU,CAAC,GAAG,OAAO,EAAE,KAAK,UAAU,EAAE,IAAI,QAAQ,GAAG;AAChE,QAAI,QAAQ;AACV,qBAAe,MAAM;AAAA,IACvB;AAAA,EACF;AAEA,UAAQ,MAAM;AAChB;AAEA,SAAS,MAAM,QAAsB;AACnC,MAAI,QAAQ,IAAI,MAAM,GAAG;AACvB;AAAA,EACF;AAEA,MAAI,QAAQ,SAAS,GAAG;AACtB,mBAAe,MAAM;AAAA,EACvB;AAEA,UAAQ,IAAI,MAAM;AAElB,aAAW,YAAY,YAAY,IAAI,MAAM,GAAG,aAAa,CAAC,GAAG;AAC/D,UAAM,QAAQ;AAAA,EAChB;AACF;AAOO,SAAS,QACd,OAC0B;AAC1B,QAAM,CAAC,cAAc,OAAO,IAAI,QAAQ,OAAO;AAC/C,QAAMA,WAAa,CAAC;AAEpB,MAAI;AACF,WAAO,OAAOA,UAAS,MAAM,CAAC;AAAA,EAChC,UAAE;AACA,YAAQ;AAAA,EACV;AAEA,QAAMC,MAAK,OAAO;AAElB,aAAW,cAAc,cAAc;AACrC,gBAAY,IAAI,UAAU,GAAG,UAAU,IAAIA,GAAE;AAAA,EAC/C;AAEA,cAAY,IAAIA,KAAI;AAAA,IAClB,UAAU,CAAC,GAAG,YAAY,EAAE,IAAI,UAAU,EAAE,OAAO,OAAO,EAAE,IAAI;AAAA,IAChE,WAAW,oBAAI,IAAI;AAAA,IACnB,SAAS;AACP,aAAO,OAAOD,UAAS,MAAM,CAAC;AAAA,IAChC;AAAA,EACF,CAAC;AAED,SAAO,IAAI,MAAgCA,UAAS;AAAA,IAClD,IAAI,QAAQ,UAAU,UAAU;AAC9B,UAAI,aAAa,UAAU;AACzB,eAAO,MAAM;AACX,qBAAW,cAAc,cAAc;AACrC,wBAAY,IAAI,UAAU,GAAG,UAAU,OAAOC,GAAE;AAAA,UAClD;AAEA,uBAAa,MAAM;AACnB,uBAAa,OAAOA,GAAE;AAAA,QACxB;AAAA,MACF;AAEA,eAAS,IAAIA,GAAE;AAEf,aAAO,QAAQ,IAAI,QAAQ,UAAU,QAAQ;AAAA,IAC/C;AAAA,IACA,MAAM;AACJ,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AACH;AAMO,SAAS,WAAWC,cAA2B;AACpD,aAAW,cAAcA,cAAa;AACpC,eAAW,QAAQ,EAAE;AAAA,EACvB;AACF;AAOO,SAAS,QAA0B,OAAsB;AAC9D,QAAMD,MAAK,OAAO;AAElB,cAAY,IAAIA,KAAI;AAAA,IAClB,UAAU;AAAA,IACV,WAAW,oBAAI,IAAI;AAAA,EACrB,CAAC;AAED,SAAO,IAAI,MAAkB,OAAO;AAAA,IAClC,IAAI,QAAQ,UAAU,UAAU;AAC9B,UAAI,OAAO,aAAa,YAAY,SAAS,WAAW,MAAM,GAAG;AAC/D,eACE,MAAMA,GAAE,GACR,QAAQ,IAAI,QAAQ,SAAS,UAAU,OAAO,MAAM,GAAG,QAAQ;AAAA,MAEnE;AAEA,eAAS,IAAIA,GAAE;AAEf,aAAO,QAAQ,IAAI,QAAQ,UAAU,QAAQ;AAAA,IAC/C;AAAA,IACA,IAAI,QAAQ,UAAU,OAAO,UAAU;AACrC,UAAI,OAAO,aAAa,YAAY,SAAS,WAAW,MAAM,GAAG;AAC/D,eAAO;AAAA,MACT;AAEA,YAAMA,GAAE;AAER,aAAO,QAAQ,IAAI,QAAQ,UAAU,OAAO,QAAQ;AAAA,IACtD;AAAA,EACF,CAAC;AACH;AAEA,SAAS,QACP,cAC6B;AAC7B,SAAO,CAAE,UAAU,oBAAI,IAAI,GAAI,MAAO,UAAU,YAAa;AAC/D;AAEA,SAAS,WAAW,YAA4B;AAC9C,SAAO,YAAY,IAAI,UAAU,GAAG,YAAY;AAClD;AAEA,SAAS,MAAM,GAAW,GAAmB;AAC3C,SAAO,KAAK,IAAI,GAAG,CAAC;AACtB;AAEA,SAAS,SAAS,YAA8C;AAC9D,SAAO,YAAY,IAAI,UAAU,GAAG;AACtC;;;AC9KA,IAAM,cAAc,oBAAI,QAA4B;AAO7C,SAAS,aAAa,SAAe,WAA2B;AACrE,MAAI,OAAO,YAAY,IAAI,IAAI;AAE/B,MAAI,CAAC,MAAM;AACT,gBAAY,IAAI,MAAO,OAAO,CAAC,CAAE;AAAA,EACnC;AAEA,OAAK,KAAK,GAAG,UAAU,IAAI,OAAO,CAAC;AACrC;AAOO,SAAS,gBAAgB,MAAkB;AAChD,QAAM,OAAO,YAAY,IAAI,IAAI;AAEjC,MAAI,CAAC,MAAM;AACT;AAAA,EACF;AAEA,aAAW,cAAc,MAAM;AAC7B,YAAQ,UAAU;AAAA,EACpB;AAEA,cAAY,OAAO,IAAI;AACzB;;;AClCA,IAAM,YAAY,oBAAI,QAOpB;AAOK,SAAS,qBAAqB,MAAkB;AACrD,aAAW,CAAC,MAAM,UAAU,OAAO,KAAK,UAAU,IAAI,IAAI,KAAK,CAAC,GAAG;AACjE,SAAK,oBAAoB,MAAM,UAAU,OAAO;AAAA,EAClD;AACF;AA0BO,SAAS,GACd,MACA,UACA,SACY;AACZ,SAAO,KAAK,CAAC,SAAS;AACpB,SAAK,iBAAiB,MAAM,UAAU,OAAO;AAE7C,QAAI,UAAU,IAAI,IAAI,GAAG,KAAK,CAAC,MAAM,UAAU,OAAO,CAAC,MAAM,QAAW;AACtE,gBAAU,IAAI,MAAM,CAAC,CAAC,MAAM,UAAU,OAAO,CAAC,CAAC;AAAA,IACjD;AAAA,EACF,CAAC;AACH;;;AC1DA,IAAM,gBAAgB,oBAAI,QAAc;AAOjC,SAAS,WAAW,MAAqB;AAC9C,SAAO,cAAc,IAAI,IAAI;AAC/B;AAOO,SAAS,SAAyB,MAAY;AACnD,SAAO,cAAc,IAAI,IAAI,GAAG;AAClC;;;ACTO,SAAS,OAAO,MAAY,OAAuB;AACxD,MAAI,CAAC,SAAS,WAAW,IAAI,GAAG;AAC9B;AAAA,EACF;AAEA,aAAW,SAAS,CAAC,GAAG,KAAK,UAAU,GAAG;AACxC,WAAO,OAAO,KAAK;AAAA,EACrB;AAEA,kBAAgB,IAAI;AACpB,uBAAqB,IAAI;AACzB,OAAK,YAAY,YAAY,IAAI;AACnC;;;ACuBA,IAAM,SAAwB,OAAO;AAErC,SAAS,MACP,MACA,QACA,WACM;AACN,MAAI,UAAU,MAAM;AAClB;AAAA,EACF;AAEA,UAAQ,OAAO,QAAQ;AAAA,IACrB,KAAK;AACH,aAAO,cAAc,MAAM,QAAQ,SAAS;AAAA,IAE9C,KAAK;AACH,UAAI,UAAU,QAAQ;AACpB,eAAO,MAAM,MAAM,OAAO,MAAM,EAAE,IAAI,GAAG,SAAS;AAAA,MACpD;AAEA,UAAI,cAAc,QAAQ;AACxB,eAAO,UAAU,MAAM;AAAA,MACzB;AAEA,UAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,mBAAW,UAAU,QAAQ;AAC3B,gBAAM,MAAM,QAAQ,SAAS;AAAA,QAC/B;AAAA,MACF,OAAO;AACL,eAAO,OAAO,MAAM,MAAM;AAAA,MAC5B;AAEA;AAAA,EACJ;AAEA,MAAI,KAAK,eAAe;AACtB,cAAU,KAAK,cAAc,eAAe,OAAO,MAAM,CAAC,CAAC;AAAA,EAC7D;AACF;AAEA,SAAS,cACP,MACA,UACA,WACM;AACN,QAAM,WAAmB,CAAC;AAE1B,MAAI;AACJ,MAAI;AAEJ,WAAS,eAAe,OAAa;AACnC,aAAS,KAAK,KAAK;AAAA,EACrB;AAEA,WAAS,SAAS;AAChB,UAAM,WAAW,KAAK;AAEtB,QAAI,CAAC,UAAU;AACb;AAAA,IACF;AAEA,QAAI,CAAC,OAAO;AACV,UAAI,SAAS,WAAW,GAAG;AACzB;AAAA,MACF;AAEA,gBAAW,QAAQ,SAAS,eAAe,EAAE,CAAE;AAC/C,gBAAW,MAAM,SAAS,eAAe,EAAE,CAAE;AAAA,IAC/C;AAEA,UAAM,QAAQ,SAAS,YAAY;AAEnC,UAAM,cAAc,KAAK;AACzB,UAAM,aAAa,GAAG;AAEtB,UAAM,WAAW,MAAM,gBAAgB;AAEvC,eAAW,QAAQ,KAAK,QAAQ;AAEhC,QAAI,SAAS,WAAW,GAAG;AACzB;AAAA,IACF;AAEA,UAAM,WAAW,SAAS,uBAAuB;AAEjD,aAAS,OAAO,GAAG,QAAQ;AAC3B,UAAM,WAAW,QAAQ;AAAA,EAC3B;AAEA,eAAa,MAAM,MAAM;AACvB,UAAM,MAAM,SAAS,IAAI,GAAG,cAAc;AAC1C,WAAO;AAEP,aAAS,SAAS;AAAA,EACpB,CAAC;AACH;AAOO,SAAS,KAAqB,UAAgC;AACnE,SAAO;AAAA,IACL,CAAC,MAAM,GAAG;AAAA,EACZ;AACF;AAQO,SAAS,IAAoB,SAAY,SAAyB;AACvE,WAAS,UAAU,OAAa;AAC9B,SAAK,YAAY,KAAK;AAAA,EACxB;AAEA,aAAW,UAAU,SAAS;AAC5B,UAAM,MAAM,QAAQ,SAAS;AAAA,EAC/B;AAEA,SAAO;AACT;;;AChKO,SAAS,WACdE,aACA,WACS;AACT,gBAAc;AAEd,SAAO,KAAK,CAAC,YAAY;AACvB,eAAW,CAAC,MAAM,KAAK,KAAK,OAAO,QAAQA,WAAU,GAAG;AACtD,UAAI,SAAS,MAAM;AACjB,eAAO,QAAQ,kBAAkB,WAAW,IAAI;AAAA,MAClD;AAEA,cAAQ,eAAe,WAAW,MAAM,OAAO,KAAK,CAAC;AAAA,IACvD;AAAA,EACF,CAAC;AACH;;;AC0BO,SAAS,KAAK,UAAoB,WAA2B;AAClE,QAAM,gBACJ,cAAc,SACV,CAAC,QAAQ,SAAS,cAAc,GAAG,IACnC,CAAC,QAAQ,SAAS,gBAAgB,WAAW,GAAG;AAEtD,SAAO,IAAI;AAAA,IACT,CAAC;AAAA,IACD;AAAA,MACE,IAAI,GAAG,UAAU;AACf,YAAI,OAAO,aAAa,UAAU;AAChC,iBAAO;AAAA,QACT;AAEA,eAAO,IAAI,YAA4B;AACrC,iBAAO,IAAI,cAAc,QAAQ,GAAG,GAAG,OAAO;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;",
  "names": ["mutable", "id", "disposables", "attributes"]
}
