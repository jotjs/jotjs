{
  "version": 3,
  "sources": ["../src/main/attributes.ts", "../src/main/state.ts", "../src/main/observers.ts", "../src/main/on.ts", "../src/main/reusable.ts", "../src/main/remove.ts", "../src/main/jot.ts", "../src/main/tags.ts", "../src/main/id.ts", "../src/main/css.ts"],
  "sourcesContent": ["import { hook, type Hook } from \"./mod.ts\";\n\n/**\n *\n * @param attributes\n * @param namespace\n * @returns\n */\nexport function attributes<E extends Element>(\n  attributes: Record<string, unknown>,\n  namespace?: string | null,\n): Hook<E> {\n  namespace ||= null;\n\n  return hook((element) => {\n    for (const [name, value] of Object.entries(attributes)) {\n      if (value == null) {\n        return element.removeAttributeNS(namespace, name);\n      }\n\n      element.setAttributeNS(namespace, name, String(value));\n    }\n  });\n}\n", "/**\n *\n */\nexport interface Accessor<V> {\n  (): V;\n}\n\n/**\n *\n */\nexport interface Mutator<V> {\n  (next: V): void;\n}\n\n/**\n *\n */\nexport interface Supplier<V> {\n  (update?: boolean): V;\n}\n\ntype Observable = [number, Set<symbol>] | [number, Set<symbol>, VoidFunction];\n\nconst context = <Set<symbol>[]>[];\nconst updates = new Set<symbol>();\nconst observables = new WeakMap<symbol, Observable>();\n\nconst byDistance = (a: symbol, b: symbol) => toDistance(a) - toDistance(b);\n\nconst isNonNullable = <V>(value?: V): value is NonNullable<V> => value != null;\n\nconst commit = () => {\n  [...updates]\n    .sort(byDistance)\n    .map(toUpdate)\n    .filter(isNonNullable)\n    .forEach(queueMicrotask);\n\n  updates.clear();\n};\n\nconst defer = (update: symbol) => {\n  if (!updates.has(update)) {\n    if (updates.size === 0) {\n      queueMicrotask(commit);\n    }\n\n    updates.add(update);\n    (getObservers(update) || []).forEach(defer);\n  }\n};\n\nconst getObservable = (id: symbol) => observables.get(id);\n\nconst getObservers = (observable: symbol) => getObservable(observable)?.[1];\n\n/**\n *\n * @param expression\n * @returns\n */\nexport const spy = <V>(expression: () => V): [Accessor<V>, VoidFunction] => {\n  const dependencies = new Set<symbol>();\n\n  context.push(dependencies);\n\n  let value: V;\n\n  try {\n    value = expression();\n  } finally {\n    context.pop();\n  }\n\n  const id = Symbol();\n\n  for (const dependency of dependencies) {\n    getObservers(dependency)?.add(id);\n  }\n\n  observables.set(id, [\n    [...dependencies].map(toDistance).reduce(toMax, -1) + 1,\n    new Set(),\n    () => (value = expression()),\n  ]);\n\n  return [\n    () => (track(id), value),\n    () => {\n      for (const dependency of dependencies) {\n        getObservers(dependency)?.delete(id);\n      }\n\n      dependencies.clear();\n      observables.delete(id);\n    },\n  ];\n};\n\nfunction toDistance(observable: symbol): number {\n  return getObservable(observable)?.[0] || 0;\n}\n\nfunction toMax(a: number, b: number): number {\n  return Math.max(a, b);\n}\n\nfunction toUpdate(observable: symbol): VoidFunction | undefined {\n  return getObservable(observable)?.[2];\n}\n\nfunction track(observable: symbol): void {\n  context[context.length - 1]?.add(observable);\n}\n\n/**\n *\n * @param value\n * @returns\n */\nexport function use<V>(value: V): [Supplier<V>, Mutator<V>] {\n  const id = Symbol();\n\n  observables.set(id, [0, new Set()]);\n\n  return [\n    (update) => (update ? defer(id) : track(id), value),\n    (next) => ((value = next), defer(id)),\n  ];\n}\n", "import { spy } from \"./state.ts\";\n\nconst nodeDisposables = new WeakMap<Node, VoidFunction[]>();\n\n/**\n *\n * @param node\n * @param observers\n */\nexport function addObservers(node: Node, ...observers: VoidFunction[]) {\n  let disposables = nodeDisposables.get(node);\n\n  if (!disposables) {\n    nodeDisposables.set(node, (disposables = []));\n  }\n\n  disposables.push(...observers.map(spy).map(toDisposable));\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeObservers(node: Node): void {\n  for (const dispose of nodeDisposables.get(node) || []) {\n    dispose();\n  }\n\n  nodeDisposables.delete(node);\n}\n\nfunction toDisposable(derived: [unknown, VoidFunction]): VoidFunction {\n  return derived[1];\n}\n", "import { hook, type Hook } from \"./jot.ts\";\n\nconst listeners = new WeakMap<\n  Node,\n  [\n    string,\n    EventListenerOrEventListenerObject | null,\n    AddEventListenerOptions | boolean | undefined,\n  ][]\n>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function removeEventListeners(node: Node): void {\n  for (const [type, listener, options] of listeners.get(node) || []) {\n    node.removeEventListener(type, listener, options);\n  }\n}\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node, T extends keyof E, E = HTMLElementEventMap>(\n  type: T,\n  listener: (this: N, event: E[T]) => unknown,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\n/**\n *\n * @param type\n * @param listener\n * @param options\n */\nexport function on<N extends Node>(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<N>;\n\nexport function on(\n  type: string,\n  listener: EventListenerOrEventListenerObject | null,\n  options?: AddEventListenerOptions | boolean,\n): Hook<Node> {\n  return hook((node) => {\n    node.addEventListener(type, listener, options);\n\n    if (listeners.get(node)?.push([type, listener, options]) === undefined) {\n      listeners.set(node, [[type, listener, options]]);\n    }\n  });\n}\n", "const reusableNodes = new WeakSet<Node>();\n\n/**\n *\n * @param node\n * @returns\n */\nexport function isReusable(node: Node): boolean {\n  return reusableNodes.has(node);\n}\n\n/**\n *\n * @param node\n * @returns\n */\nexport function reusable<N extends Node>(node: N): N {\n  return reusableNodes.add(node), node;\n}\n", "import { removeObservers } from \"./observers.ts\";\nimport { removeEventListeners } from \"./on.ts\";\nimport { isReusable } from \"./reusable.ts\";\n\n/**\n *\n * @param node\n * @param force\n */\nexport function remove(node: Node, force?: boolean): void {\n  if (!force && isReusable(node)) {\n    return;\n  }\n\n  for (const child of [...node.childNodes]) {\n    remove(child, force);\n  }\n\n  removeObservers(node);\n  removeEventListeners(node);\n  node.parentNode?.removeChild(node);\n}\n", "import { addObservers } from \"./observers.ts\";\nimport { remove } from \"./remove.ts\";\n\n/**\n *\n */\nexport interface Callback<N extends Node> {\n  (node: N): Option<N>;\n}\n\n/**\n *\n */\nexport interface Hook<N extends Node> {\n  [hookTo](node: N): Option<N>;\n}\n\n/**\n *\n */\nexport type Option<N extends Node> =\n  | bigint\n  | boolean\n  | Callback<N>\n  | Hook<N>\n  | Node\n  | null\n  | number\n  | Option<N>[]\n  | Properties<N>\n  | string\n  | symbol\n  | undefined\n  | void;\n\n/**\n *\n */\nexport type Properties<N extends Node> = Partial<Omit<N, \"nodeType\">>;\n\nconst hookTo: unique symbol = Symbol();\n\nfunction apply<N extends Node>(\n  node: N,\n  append: (node: Node) => void,\n  option: Option<N>,\n): void {\n  if (option == null) {\n    return;\n  }\n\n  switch (typeof option) {\n    case \"function\": {\n      return applyCallback(node, append, option);\n    }\n\n    case \"object\": {\n      if (\"nodeType\" in option) {\n        return append(option);\n      }\n\n      const applyObject = apply.bind<\n        undefined,\n        [N, (node: Node) => void],\n        [Option<N>],\n        void\n      >(undefined, node, append);\n\n      if (hookTo in option) {\n        return applyObject(option[hookTo](node));\n      }\n\n      return Array.isArray(option)\n        ? option.forEach(applyObject)\n        : void Object.assign(node, option);\n    }\n  }\n\n  if (node.ownerDocument) {\n    append(node.ownerDocument.createTextNode(String(option)));\n  }\n}\n\nfunction applyCallback<N extends Node>(\n  node: N,\n  append: (node: Node) => void,\n  callback: Callback<N>,\n): void {\n  const children: Node[] = [];\n\n  let start: Text;\n  let end: Text;\n\n  const push = children.push.bind(children);\n\n  function update() {\n    const document = node.ownerDocument;\n\n    if (!document) {\n      return;\n    }\n\n    if (!start) {\n      if (children.length === 0) {\n        return;\n      }\n\n      append((start = document.createTextNode(\"\")));\n      append((end = document.createTextNode(\"\")));\n    }\n\n    const range = document.createRange();\n\n    range.setStartAfter(start);\n    range.setEndBefore(end);\n\n    const contents = range.extractContents();\n\n    setTimeout(remove, 100, contents);\n\n    if (children.length === 0) {\n      return;\n    }\n\n    const fragment = document.createDocumentFragment();\n\n    fragment.append(...children);\n    range.insertNode(fragment);\n  }\n\n  addObservers(node, () => {\n    apply(node, push, callback(node));\n    update();\n\n    children.length = 0;\n  });\n}\n\n/**\n *\n * @param callback\n * @returns\n */\nexport function hook<N extends Node>(callback: Callback<N>): Hook<N> {\n  return {\n    [hookTo]: callback,\n  };\n}\n\n/**\n *\n * @param node\n * @param options\n * @returns\n */\nexport function jot<N extends Node>(node: N, ...options: Option<N>[]): N {\n  const append = node.appendChild.bind(node);\n  const applyOption = apply.bind<\n    undefined,\n    [N, (node: Node) => void],\n    [Option<N>],\n    void\n  >(undefined, node, append);\n\n  return options.forEach(applyOption), node;\n}\n", "import { jot, type Option } from \"./jot.ts\";\n\n/**\n *\n */\nexport type Tags<E extends Record<keyof E, Node>> = {\n  readonly [T in keyof E]: (...options: Option<E[T]>[]) => E[T];\n};\n\nfunction tag(this: () => Node, ...options: Option<Node>[]): Node {\n  return jot(this(), ...options);\n}\n\n/**\n *\n * @param document\n * @param namespace\n * @returns\n */\nexport function tags(\n  document: Document,\n  namespace?: \"http://www.w3.org/1999/xhtml\",\n): Tags<HTMLElementTagNameMap> & Tags<HTMLElementDeprecatedTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n * @returns\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/1998/Math/MathML\",\n): Tags<MathMLElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n * @returns\n */\nexport function tags(\n  document: Document,\n  namespace: \"http://www.w3.org/2000/svg\",\n): Tags<SVGElementTagNameMap>;\n\n/**\n *\n * @param document\n * @param namespace\n * @returns\n */\nexport function tags(\n  document: Document,\n  namespace: string | null,\n): Tags<Record<string, Element>>;\n\nexport function tags(document: Document, namespace?: string | null) {\n  const createElement =\n    namespace === undefined\n      ? document.createElement.bind(document)\n      : document.createElementNS.bind(document, namespace);\n\n  return new Proxy(\n    {},\n    {\n      get(_, property) {\n        return typeof property === \"string\"\n          ? tag.bind(createElement.bind(undefined, property))\n          : undefined;\n      },\n      set() {\n        return false;\n      },\n    },\n  );\n}\n", "import { hook, type Hook } from \"./jot.ts\";\n\nlet value = 0n;\n\n/**\n *\n * @returns\n */\nexport function id<E extends Element>(): string & Hook<E> {\n  const id = String(value++);\n\n  return Object.assign(\n    id,\n    hook<E>((element) => {\n      element.id = id;\n    }),\n  );\n}\n", "import { id } from \"./id.ts\";\nimport { hook, type Hook } from \"./jot.ts\";\n\n/**\n *\n */\nexport type Style = Partial<StyleProperties> & {\n  [key: string]: string | Style | Style[];\n};\n\n/**\n *\n */\nexport type StyleProperties = Omit<\n  CSSStyleDeclaration,\n  | \"getPropertyPriority\"\n  | \"getPropertyValue\"\n  | \"item\"\n  | \"length\"\n  | \"parentRule\"\n  | \"removeProperty\"\n  | \"setProperty\"\n  | number\n  | SymbolConstructor[\"iterator\"]\n>;\n\nconst bySpace = /\\s+/;\nconst styles = new WeakSet<symbol>();\nconst upperCaseLetters = /([A-Z])/g;\n\nlet stylePrefix: string | undefined;\nlet styleSheet: CSSStyleSheet | null;\n\n/**\n *\n * @param style\n * @param global\n * @returns\n */\nexport function css<E extends Element>(\n  style: Style,\n  global?: false,\n): string & Hook<E>;\n\n/**\n *\n * @param style\n * @param global\n * @returns\n */\nexport function css<E extends Element>(style: Style, global: true): Hook<E>;\n\nexport function css<E extends Element>(\n  style: Style,\n  global?: boolean,\n): Hook<E> {\n  const styleId = Symbol();\n\n  if (global) {\n    return hook((element) => {\n      if (styles.has(styleId)) {\n        return;\n      }\n\n      const styleSheet = getStyleSheet(element.ownerDocument);\n\n      for (const [selector, value] of Object.entries(style)) {\n        if (typeof value === \"string\") {\n          insert(styleSheet, selector, value);\n        } else {\n          for (const style of Array.isArray(value) ? value : [value]) {\n            insert(styleSheet, selector, toString(style));\n          }\n        }\n      }\n\n      styles.add(styleId);\n    });\n  }\n\n  const className = (stylePrefix || \"s\") + id();\n\n  return Object.assign(\n    className,\n    hook<E>((element) => {\n      if (!styles.has(styleId)) {\n        insert(\n          getStyleSheet(element.ownerDocument),\n          `.${className}`,\n          toString(style),\n        );\n      }\n\n      element.classList.add(className);\n    }),\n  );\n}\n\nfunction getStyleSheet(document: Document): CSSStyleSheet {\n  if (styleSheet) {\n    return styleSheet;\n  }\n\n  const style = document.createElement(\"style\");\n\n  document.head.appendChild(style);\n\n  styleSheet = style.sheet;\n\n  return getStyleSheet(document);\n}\n\nfunction insert(styleSheet: CSSStyleSheet, selector: string, rule: string) {\n  styleSheet.insertRule(`${selector}{${rule}}`, styleSheet.cssRules.length);\n}\n\n/**\n *\n * @param prefix\n */\nexport function setStylePrefix(prefix: string): void {\n  stylePrefix = prefix;\n}\n\n/**\n *\n * @param sheet\n */\nexport function setStyleSheet(sheet: CSSStyleSheet | null): void {\n  styleSheet = sheet;\n}\n\n/**\n *\n * @param className\n * @param force\n * @returns\n */\nexport function toggle<E extends Element>(\n  classNames: string,\n  force?: boolean,\n): Hook<E> {\n  return hook((element) => {\n    for (const className of classNames.split(bySpace)) {\n      element.classList.toggle(className, force);\n    }\n  });\n}\n\nfunction toString(style: Style): string {\n  return Object.entries(style).map(toStyleString).join(\"\");\n}\n\nfunction toStyleString([key, style]: [\n  string,\n  string | Style | Style[],\n]): string {\n  if (typeof style === \"string\") {\n    if (!key.startsWith(\"--\")) {\n      key = key.replaceAll(upperCaseLetters, \"-$1\").toLowerCase();\n    }\n\n    return `${key}:${style};`;\n  }\n\n  return (Array.isArray(style) ? style : [style])\n    .map((style) => `${key}{${toString(style)}}`)\n    .join(\"\");\n}\n"],
  "mappings": "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",
  "names": ["attributes", "value", "value", "id", "id", "styleSheet", "value", "style"]
}
